p8105_hw1_bk2959
================
Stella Koo
2024-09-13

## Problem 1

``` r
data("penguins", package = "palmerpenguins")

library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

The `penguins` dataset contains 344 rows and 8 columns. It provides
detailed information about three different `species` of penguins
(Adelie, Chinstrap, and Gentoo) and their respective `island` (Biscoe,
Dream, and Torgersen). The dataset includes important biometric
measurements for each penguin, such as:

- Bill length: `bill_length_mm`
- Bill depth: `bill_depth_mm`
- Flipper length: `flipper_length_mm`
- Body mass: `body_mass_g`

The mean flipper length is 200.9152047.

``` r
ggplot(penguins, aes(x = bill_length_mm, y = flipper_length_mm, color = species)) + geom_point()
```

    ## Warning: Removed 2 rows containing missing values or values outside the scale range
    ## (`geom_point()`).

![](p8105_hw1_bk2959_files/figure-gfm/unnamed-chunk-2-1.png)<!-- -->

``` r
ggsave("penguins_scatter_plot.pdf")
```

    ## Saving 7 x 5 in image

    ## Warning: Removed 2 rows containing missing values or values outside the scale range
    ## (`geom_point()`).

## Problem 2

``` r
set.seed(1)

problem_df = tibble(
  norm_samp = rnorm(10),
  norm_samp_pos = norm_samp > 0,
  vec_char = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J"),
  vec_factor = factor(c("Level 1", "Level 1", "Level 2", "Level 3", "Level 2", "Level 1", "Level 2", "Level 3", "Level 3", "Level 1"))
)

problem_df
```

    ## # A tibble: 10 × 4
    ##    norm_samp norm_samp_pos vec_char vec_factor
    ##        <dbl> <lgl>         <chr>    <fct>     
    ##  1    -0.626 FALSE         A        Level 1   
    ##  2     0.184 TRUE          B        Level 1   
    ##  3    -0.836 FALSE         C        Level 2   
    ##  4     1.60  TRUE          D        Level 3   
    ##  5     0.330 TRUE          E        Level 2   
    ##  6    -0.820 FALSE         F        Level 1   
    ##  7     0.487 TRUE          G        Level 2   
    ##  8     0.738 TRUE          H        Level 3   
    ##  9     0.576 TRUE          I        Level 3   
    ## 10    -0.305 FALSE         J        Level 1

``` r
mean_norm_samp = mean(pull(problem_df, norm_samp))
mean_norm_samp_pos = mean(pull(problem_df, norm_samp_pos))
mean_vec_char = mean(pull(problem_df, vec_char))
```

    ## Warning in mean.default(pull(problem_df, vec_char)): argument is not numeric or
    ## logical: returning NA

``` r
mean_vec_factor = mean(pull(problem_df, vec_factor))
```

    ## Warning in mean.default(pull(problem_df, vec_factor)): argument is not numeric
    ## or logical: returning NA

When calculating the mean for each variable, only `norm_samp` and
`norm_samp_pos` yielded valid results. This is because `norm_samp` is
numeric, and `norm_samp_pos` is logical, where the mean reflects the
proportion of TRUE values. In contrast, `vec_char` and `vec_factor` are
non-numeric types and results in NA.

``` r
numeric_vec_char = as.numeric(pull(problem_df, vec_char))
```

    ## Warning: NAs introduced by coercion

``` r
numeric_vec_factor = as.numeric(pull(problem_df, vec_factor))

mean_numeric_vec_char = mean(numeric_vec_char)
mean_numeric_vec_factor = mean(numeric_vec_factor)
```

After applying `as.numeric` to `vec_char` and `vec_factor`, only
`numeric_vec_factor` yielded valid result while `numeric_vec_char`
produced NA. This occurs because character values in `vec_char` cannot
be directly converted into numeric form. in contrast, `as.numeric`
converts factor levels in `vec_factor` into their corresponding integer
codes. “Level 1” is converted to 1, “Level 2” to 2 and “Level 3” to 3.
